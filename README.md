# Moviemax 

## Общие принципы

### Рекомендации

1. Проставлять `final` всем классам, которые не имеют наследников.
2. Использовать `typealias` для именования `closure`

```swift
typealias SelectHandler = (Int) -> Void

...

func didSelect(_ handler: SelectHandler) { /* ... */ }

```

### Логические переменные

Предпочтительно называть логические переменные по правилу is+прилагательное (также подходят другие глаголы вроде has/should/needs и прочие):

```swift
    let isAvailable = false
    let shouldEnableFeature = false

    //вместо
    let available = false
    let enableFeature = false
```
    
### Использование отрицаний

Ориентируемся на рекомендации

1. Стараемся избегать лишних отрицаний в guard и if - else
2. guard обычно предпочтительнее, особенно если он сокращает код

```swift
func run () {
    // -- Логика 
    guard let model else { return }
    // -- Логика
}
```

### Функции

1. Название функций должно быть коротким (вмещаться на одной строке) и однозначным. При чтении названия функции должно быть понятно, какую задачу она выполняет.
2. Функция должна принимать в качестве аргументов не более 3 параметров. Для функций с числом аргументов больше 3-х необходимо в комментарии к функции ответить на вопрос "почему здесь необходимо использовать столько аргументов?". Если ваша функция требует больше 3-х, то, скорее всего:
    - функция выполняет слишком много действий и ее нужно разбить на более мелкие или даже вынести в отдельный класс;
    - параметры связаны, т.о. должны быть объединены в структуру или класс и передаваться как один параметр;
    - это действительно необходимо, тогда вы без труда ответите на вопрос выше.
3. Допускается использование дефолтных значений для аргументов функций.

Предпочтительно называть функции с аргументами так, чтобы было понятно, какие аргументы нужно передавать, но не требовалось явно указывать название аргумента (правило применяется только для пар глагол+существительное):
```swift
    func eatSomeCookies(_ cookies: [Cookie]) {/* … */}
    // вместо
    func eat(someCookies: [Cookie]) {/* … */}
```

Если после пары глагол+существительное следует предлог, то сама пара остается в названии функции, а предлог используется в качестве ярлыка для параметра, причем название параметра должно быть существительным:
```swift
    func getResource(for path: URL) {/* … */}
    // вместо
    func get(resourceForPath: URL) {/* … */}
    func getResourceFor(_ path: URL) {/* … */}
    func getResourceFor(path: URL) {/* … */}
    func getResourceForPath(path: URL) {/* … */}
    func getResourceForPath(_ path: URL) {/* … */}
```

### Протоколы

Название протокола должно говорить о том, какое поведение он описывает.
Если протокол предполагает единственную реализацию, нужно называть его по имени класса, который его реализует, с суффиксом Protocol.
В остальных случаях рекомендуется опускать суффикс Protocol и называть протокол отглагольным прилагательным с суффиксом "-able” или отглагольным существительным на "-er".

```swift
// Примеры:
1. KeychainServiceProtocol
2. Downloadable
3. AsyncFetcher

```

### Комментарии
1. Код должен быть быть самодокументированным, Неочевидных вещей быть не должно, но если вдруг так получилось, то такие места должны быть описаны комментариями. Комментарии пишутся на русском языке.
2. Если необходимо пометить место, например, для будущего рефакторинга, необходимо использовать комментарии вида `// TODO: Текст комментария`
3. Если класс большой, желательно разбивать код на логические части и использовать `// MARK: -` для подписи. (например `// MARK: - Lyficycle`)
4. Других марков быть не должно - либо TODO, либо FIXME


## Ослабление ссылок на self в замыканиях
---

Во избежание retain cycle'ов в escaping замыканиях следует ослаблять ссылки на self.

```swift
Timer.scheduledTimer(withTimeInterval: dissmissAfter, repeats: true) { [weak self] _ in
    self?.service.foo()
}

// либо

Timer.scheduledTimer(withTimeInterval: dissmissAfter, repeats: true) { [weak service] _ in
    service?.foo()
}

```

## Советы по оптимизации
---

1. Используйте final для классов и свойств, если уверены, что свойства и классы не будут наследоваться, таким образом вы сократите время выполнения кода
2. Используется private, fileprivate для свойств и классов, это ограничит область видимости, что упростит работу при вызове метода/свойства компилятору
3. Укажите протоколы, которые реализуются только `class`, как `protocol A: AnyObject`, без этих знаний компилятору придется предположить что там может быть `value type` и он должен быть готов обработать нетривиальные структуры, которые могут быть «дорогими»
4. Использовать интерполяцию строк вместо конкатенации.

```swift
let foo = "foo"
let bar = "bar"

let foobar = "\(foo) \(bar)"

// вместо
let foobar = foo + bar
```

5. При объявлении переменных/полей указывать тип явно в левой части выражения:

```swift
let buttonTitleFont: UIFont = .regularAppFontOfSize17
// вместо
let buttonTitleFont = UIFont.regularAppFontOfSize17
```

### Рекомендации
---

1. Если класс имплементирует какой-нибудь протокол, необходимо выносить этот код в extension.
2. Class only протоколы должны использовать для объявления AnyObject. Ключевое слово class для этих целей использовать не рекомендуется (потому что: [тыц](https://stackoverflow.com/questions/30176814/whats-the-difference-between-a-protocol-extended-from-anyobject-and-a-class-onl), [тыц](https://forums.swift.org/t/class-only-protocols-class-vs-anyobject/11507/4))#


## Рефакторинг
---

Стараемся придерживаться "Правила бойскаута":

> Всегда оставляйте код чище, чем вы его застали.

То есть приводим в порядок код, с которым работаем.

**Важно!** Как улучшать код, чтобы не отхватить на ПРах?

- Не исправляем конструкции, на которых нет правил в гайдлайнах. Если хочется исправить – дополняем гайды.
- Если это дело вкуса – не меняем.
- Перед началом **крупного** рефакторинга стоит убедиться, что это действительно нужно. Может оказаться, что модуль не планируется развивать или он будет удален в ближайшем будущем.

# Типичные конструкции
> ### Соглашения по именованию
>Понятное именование полей и методов существенно увеличивает читаемость кода.
>Следует использовать принятые в swift правила [API Design Guidelines](https://swift.org/documentation/api-design-guidelines/).
> Ниже будут приведены конструкции, которые используются по всему проекту и для их изменения необходимы апрувы в ревью с обьяснением почему дефолтную конструцию необходимо заменить.
> Обязательно используем нативные средства форматирования Xcode `Cmnd+A -> Ctrl+I`

---

## Переносы
### Guard

**Пример**:
В случае наличия нескольких условий, они переносятся на новую строку с одним табом, при этом `else` должен находиться на одном уровне с `guard`

**Пример**:

      guard
          let something = some,
          let something1 = some1
      else {
          return
    }

При необходимости извлечения слабой ссылки на `self` используем стандартный нейминг

**Пример**:

      guard let self else { return }

### Тернарный оператор

В случаях когда условия и варианты выполнения простые (в один оператор) и присутствует сохранение результата тернарного выполнения используется тернарный оператор.

**Пример**:

    bigTerm ? variant : variant1

Если условия не помещаются в одну строку, то каждое условие переносится на новую строку со стандартным отступом.

### Массивы

Проверяем наличие элементов в массиве через `isEmpty`

**Пример**:

    array.isEmpty

<br /> Обращаемся к элементам через `safe`

**Пример**:

    array[safe: index]

### Параметры в функциях:

Если параметры не помещаются в одну строку используется перенос

**Пример**:

    func funcName(
        paramName0: ParamType0
        paramName1: ParamType1,
        paramName2: ParamType2,
        paramName3: ParamType3
    ) -> КакойтоТипСДлиннымНазванием {
        some executing
    }

Аналогично производится и вызов длинной функции

**Пример**:

    router.present(
        viewController: viewController,
        usingTransitionContext: context
    )

Если параметр - замыкание то закрывающую скобку замыкания `}` выравнивать по параметрам

**Пример**:

    self?.router.dismiss(
        animated: false,
        completion: {
            self?.router.pushAuthorizationModule()
       }
    )

### Общее

* Если класс не наследуется то должен быть `final`
* Название `Asset Catalog` должно совпадать с названием файла
* Строгая типизация при объявлении проперти и констант: `let value: Int = 0`
* Не нужно явно указывать тип, если переменная используется внутри метода с очевидным типом.
* В конструкциях с высшим порядком `.map .contains и тд` используем короткую запись:
<br /> вместо `.contains(where: { $0 == .test })` просто `.contains { $0 == .test }`
* Неиспользуемый код и шаблоны Xcode должны быть удалены
* Использовать negative вместо прямого присваивания отрицания

❌
`-viewHeight`

✅
`viewHeight.negative`



## Запрещается:
* использовать `unowned`
* использовать `force unwrap`
* использовать `force cast`
